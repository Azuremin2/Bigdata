# 정규 표현식 (Regular Expressions)

정규 표현식은 텍스트에서 특정 패턴을 검색하고 매칭시키는 도구입니다.  
이는 파이썬을 포함한 다양한 프로그래밍 언어에서 지원되며, 문자열 처리 작업을 보다 쉽게 수행할 수 있게 해줍니다.  
<br>
## 정규 표현식의 필요성

정규 표현식은 다음과 같은 상황에서 유용합니다:  
<br>

- 문자열에서 특정 패턴을 찾고 싶을 때  

- 문자열을 특정 기준에 따라 분리하고 싶을 때  

- 문자열에서 특정 부분을 추출하고 싶을 때  

- 문자열에 대한 유효성 검사를 수행하고 싶을 때      
<br>
## 파이썬에서의 기본 사용법

파이썬에서는 `re` 모듈을 사용하여 정규 표현식을 다룰 수 있습니다.  
주요 함수로는 `search()`, `match()`, `findall()`, `sub()` 등이 있습니다. 
<br>
<br>
<br>
<br>
<br>
# 가비지 컬렉션 (Garbage Collection)

가비지 컬렉션은 프로그래밍 언어가 자동으로 동적으로 할당한 메모리 중에서 더 이상 사용되지 않는 객체들을 찾아내고 해제하는 기능입니다.  
가비지 컬렉션은 메모리 누수를 방지하고, 개발자가 명시적으로 메모리 관리를 수행하는 부담을 줄여줍니다.
<br>
<br>
## 가비지 컬렉션의 필요성
<br>

- 프로그램에서 동적으로 할당한 메모리는 사용 후에 명시적으로 해제되어야 합니다.  

- 그러나 메모리 관리를 실수로 처리하지 않거나, 복잡한 상황에서 모든 메모리 할당 및 해제를 추적하기 어려울 수 있습니다.  

- 이로 인해 사용하지 않는 메모리가 계속 쌓여 메모리 누수로 이어질 수 있습니다.  

- 가비지 컬렉션은 이러한 문제를 해결하기 위해 자동으로 더 이상 사용되지 않는 메모리를 찾아내고 해제합니다.
<br>
<br>

## 가비지 컬렉션의 동작 메커니즘

가비지 컬렉션은 일반적으로 다음과 같은 메커니즘으로 동작합니다:
<br>
<br>

1. **Reachability (도달 가능성)**  
<br>
가비지 컬렉터는 어떤 객체가 더 이상 도달 가능한지 확인합니다. 도달 가능한 객체는 여전히 프로그램의 다른 부분에서 참조되는 객체입니다. 도달 가능하지 않은 객체는 가비지로 간주됩니다.
<br>
<br>

2. **Garbage Collection Algorithm (가비지 컬렉션 알고리즘)**  
<br>
도달 가능한 객체를 제외한 나머지 객체를 가비지로 판단하고 메모리에서 해제하는 알고리즘을 수행합니다.  
대표적인 가비지 컬렉션 알고리즘에는 "참조 카운팅 (Reference Counting)", "Mark and Sweep", "Copying", "Generational" 등이 있습니다.
<br>
<br>

   - 참조 카운팅: 객체가 참조될 때마다 참조 카운트를 증가시키고, 참조가 해제될 때마다 참조 카운트를 감소시킵니다.  
   카운트가 0이 되는 순간 해당 객체는 가비지로 간주되고 메모리에서 해제됩니다.  
   하지만 순환 참조 등의 문제로 인해 정확한 메모리 해제를 보장하기 어렵습니다.

   - Mark and Sweep: 도달 가능한 객체를 표시하고, 표시되지 않은 객체를 가비지로 간주하여 메모리에서 해제하는 알고리즘입니다.

   - Copying: 메모리를 두 개의 영역으로 나누고, 한 영역에서 다른 영역으로 도달 가능한 객체들을 복사하는 방식으로 가비지 컬렉션을 수행합니다.

   - Generational: 객체를 생성한 시점에 따라 여러 세대 (Generation)로 분류하고, 각 세대별로 가비지 컬렉션을 수행하는 방식입니다.  
<br>
<br>

3. **Memory Reclamation (메모리 회수)**  
<br>
가비지 컬렉션 후에는 해제된 메모리를 다시 사용 가능한 상태로 만들어야 합니다.  
일반적으로 해제된 메모리를 자유 메모리 풀 (Free Memory Pool) 또는 힙 (Heap)에 추가하여 다시 할당될 수 있도록 합니다.
<br>
<br>
가비지 컬렉션은 프로그래밍 언어와 런타임 환경에 따라 구체적인 구현과 동작 방식이 달라질 수 있습니다. 가비지 컬렉션은 개발자가 메모리 관리에 대한 부담을 덜어주고, 안정적이고 효율적인 메모리 관리를 제공하여 프로그램의 신뢰성과 생산성을 향상시킵니다.

